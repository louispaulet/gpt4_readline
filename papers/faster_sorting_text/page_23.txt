Input–output examples for program synthesis. A large body of work addresses the problem of learning programs from input–output pairs. One type of approach learns a neural network for matching inputs to outputs directly11,13,67,68. This approach is difficult to integrate into exist- ing libraries and can struggle to generalize to previously unseen inputs, although there has been some encouraging recent progress using graph representations69. Another type of approach is to perform a search in program space, guided by a learned model12,70–72. For instance, Chen et al.70 use a model that predicts the next program token on the basis of a partial program and the input–output pairs. This bears some similari- ties to how search is guided in our approach: the learned policy prior in AlphaZero is a model for predicting the next token, learned on the basis of a combination of a partial program and that program’s effects on the inputs. However, we are interested in finding correct and efficient programs, which we achieve by further learning a value function for approximating the expected latency of partial programs, and using AlphaZero to incorporate this value function into the search process.

Deep learning for code generation. There are also several deep learn- ing approaches that use large languages models to generate code. These approaches vary in their uses from transpilation, code refactoring and explaining code15 to generating human-level competitive code using a natural language description14. That particular work aims to generate correct code, but does not focus on generating low-latency solutions.

Sort-based program optimization. There are several program synthe- sis studies that have tackled sorting algorithms. For example, White et al.26 use RL for learning sorting functions. Their work uses several heuristics and a domain specific language to yield a sorting algorithm called reinforcement programming sort. Srivastava et al.27 encodes the program synthesis as a verification problem. Specifically, they repre- sent a synthesis task as a tuple consisting of the functional expression, the domains and guards appearing in the synthesized program and the resource constraints. The idea is that, given a prespecified resource constraint, their synthesizer produces a program that meets the pre- defined specification to ensure correctness. They apply this to discover merge sort and quick sort. Jason Ansel et al.28 takes as input predefined algorithms (for example, insertion sort, merge sort and quick sort) and then determines when to select these algorithms for execution using its autotuner function. It does so by defining a language that contains rules and transforms that dictate how the algorithms are selected and where they are executed.

Data availability The data used to train the system were generated synthetically accord- ing to the procedures explained in the paper. The algorithms discovered by AlphaDev for the copy and swap operators are presented in the main paper. We have also released the discovered AlphaDev assembly imple- mentations for sort 3–8 as well as VarSort3, 4 and 5 on Github at https://

github.com/deepmind/alphadev. We have included exhaustive tests to ensure that each implementation is correct. In addition, Appendix G in Supplementary Information contains a list of additional, correct sorting algorithms discovered by AlphaDev for sort 3, sort 4 and sort 5. The performance of the sort 3, sort 4 and sort 5 algorithms on the official LLVM benchmarking suite for three different CPU architectures as well as floats, int32 and int64 data types is detailed in Appendix E in the Supplementary Information. In addition, the AlphaDev sort 3, sort 4 and sort 5 implementations can be found in the LLVM libc++ standard sorting library3.